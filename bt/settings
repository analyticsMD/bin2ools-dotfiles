#!/usr/bin/env /usr/local/bin/bash
# shellcheck disable=SC2148,SC2034
# -----------------------------------------------------------------

export LOADER=legacy
export SOURCE_FILES=yes

. ${HOME}/.bt/lib/utils.bash 


# -----------------------------------------------------------------
# DEBUGGING
# -----------------------------------------------------------------


# global debug function.
to_debug()    { [[ "${BT_DEBUG}"    = *$1* ]] && >&2 "${@:2}" ;} || true

bt_settings() { [[ "${BT_SETTINGS}" = *$1* ]] && >&2 "${@:2}" ;} || true

# shellcheck disable=SC1090,SC1094 

i=${#BASH_SOURCE[@]}
ver="$(echo "${BASH_VERSION}"             | \
       perl -nle 'print if s/(\d+)\..*/\1/')"
[[ "${ver}" -ne 5 ]] && { 
  echo "WARNING: unsupported shell spawned: ${BASH_VERSION}"
  return 1
} || true

#export BT_DEBUG="flow env lgin rds rdsc rdst cche util data pmpt qvdb"
to_debug flow && sleep 0.5 && echo "stgs:debug" || true

# ------------------------------------------------------------------
# SETTINGS
# ------------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:settings" || true
    

#export BT_SETTINGS="_src_alog_quiet_"

# Determines whether function libraries are loaded 
# via flat files (legacy) or a newer parallel loader. 
# Default is legacy. The loader has proven problematic
# at times. 
#export LOADER="legacy"

# Add 'quiet' if you want to silence status reporting of each 
# config file when loaded. Add 'src' if you want to load BT's 
# preconfigured dotfiles (from ~/.bin2ools-dotfiles) or add your own.

# uncomment while debugging.
#export BT_DEBUG="env lgin rds rdsl rdsc rdst cche util data prmt qv"
#export BT_DEBUG="rds rdsl rdsc rdst"

export NOISE="quiet"
export SOURCE_FILES="no"
export DEFAULT_ROLE="qventus"
export DEFAULT_ACCOUNT="prod"

# finding the proper sso-lib
export AWSLIB="devops"
# fall back to aws-sso-util when devops isn't available.
[[ ! -e "${DEFAULT_AWSLIB}" ]] && { 
    export AWSLIB="aws" 
    export DEFAULT_AWSLIB="${HOME}/.local/bin/${AWSLIB}-sso-util" 
} || true

function prompt_off() { unset PROMPT_COMMAND ;}
function prompt_on() { export PROMPT_COMMAND="prompt" ;}

function prompt() {
  # generate the next cache peek,
  # and hence, the next prompt.

  PS1="$(_prompt)"
  export PS1
}


# -----------------------------------------------------------------
# ARG PARSING
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:arg_parsing"  || true

account="${1:-"prod"}"



# -----------------------------------------------------------------
# SHELL LOADER 
# -----------------------------------------------------------------

# For loading associative arrays from files or variables.


# -----------------------------------------------------------------
# SHELL SOURCER 
# -----------------------------------------------------------------
# 
# Lots of people love putting dotfile and other scripts into 
# their homedir. With this command, you can add them all to 
# Bintool and manage them through github. 

[[ "${SOURCE_FILES}" =~ "yes" ]] && { 
    source "${BT}/lib/bt_sourcer.bash" || true
    bt_source ${NOISE}
    echo -e Sourcing "${BLUE}enabled${NC}. "
}

# NOTE: this feature is controlled by adding the string 
# 'src' to the variable: BT_SETTINGS. See: the settings section. 

# -----------------------------------------------------------------
# CACHE SETTINGS
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:cache" || true
set_team || true

# -----------------------------------------------------------------
# PATH SETTINGS
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:path" || true

[[ ! -f "${BT}"/cache/path_info ]] && {
  to_debug stgs && echo stgs:path_info
  "${BT}"/utils/path -s 2>/dev/null | tee "${BT}/cache/path_info" 
} || true

to_debug stgs && sleep 0.5 && echo stgs:source_path
source <( $(${BT}/utils/path -s 2>/dev/null) )  || true



# -----------------------------------------------------------------
# ESSENTIAL ALIASES
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:aliases"  || true

#poetry="$(which poetry)"

# -----------------------------------------------------------------
# ENV SETTINGS
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:env" || true

# scripted shell activation (experimental).
#[[ -e "${HOME}/.bt/.iterm2_shell_integration.bash" ]] && { 
#  source "${HOME}/.iterm2_shell_integration.bash"
#}

# defaults should be generated by the loader.
to_debug stgs && echo stgs:env BT_TEAM:    "${BT_TEAM}" 
to_debug stgs && echo stgs:env BT_ACCOUNT: "${BT_ACCOUNT}" 
to_debug stgs && echo stgs:env BT_ROLE:    "${BT_ROLE}"

chmod 777 .

# -----------------------------------------------------------------
# Bootstrap functions.
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:bootstrap_funcs" || true





# -----------------------------------------------------------------
# AWS LOGIN
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:autologin"

# Team account defaults to prod, for now.

BT_ROLE=qventus 
autologin "${BT_ROLE}" || true



# ------------------------------------------------------------------
# load bintools functions, customizations, completions.
# ------------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:sources" || true


rds_generate() { ${SRC}/b2rds/rds_generate ${@} ;}

declare -fx rds_generate

rds_complete() { source ${SRC}/b2rds/rds_complete ${@} ;}

declare -fx rds_complete

rds_local() { ${SRC}/b2rds/rds_local ${@} ;}

declare -fx rds_local

ln -fs ${SRC}/b2rds/rds_local /Users/marc/.local/bin/rds

rds() { ${SRC}/b2rds/rds_local ${@} ;}

declare -fx rdsrds_complete

ssm_generate() { ${SRC}/b2ssm/ssm_generate ${@} ;}

declare -fx ssm_generate

ssm_complete() { source ${SRC}/b2ssm/ssm_complete ${@} ;}

declare -fx ssm_complete

ssm_local() { ${SRC}/b2ssm/ssm_local ${@} ;}

declare -fx ssm_local

ln -fs ${SRC}/b2ssm/ssm_local /Users/marc/.local/bin/ssm

ssm() { ${SRC}/b2ssm/ssm_local ${@} ;}

declare -fx ssm_complete
