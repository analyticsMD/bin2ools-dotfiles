#!/usr/bin/env /usr/local/bin/bash
# shellcheck disable=SC2148,SC2034
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# DEBUGGING
# -----------------------------------------------------------------

# global debug function.
to_debug() { [[ "${BT_DEBUG}" = *$1* ]] && >&2 "${@:2}" ;}

# shellcheck disable=SC1090,SC1094 
[[ "${BASH_VERSION:0:1}" -ne 5 ]] && { 
  echo "WARNING: unsupported shell spawned: ${BASH_VERSION}" && exit 1
}

#export BT_DEBUG="flow env lgin rds rdsc rdst cche util data pmpt qvdb"
to_debug flow && sleep 0.5 && echo "stgs:debug"


# ------------------------------------------------------------------
# SETTINGS
# ------------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:settings"

# additional config settings for BT. 
export BT=${HOME}/.bt
export BT_SETTINGS=quiet 
#export BT_SETTINGS=

# uncomment while debugging.
#export BT_DEBUG="env lgin rds rdsl rdsc rdst cche util data prmt qv"
#export BT_DEBUG="rds rdsl rdsc rdst"

export DEFAULT_ROLE="qventus"
export DEFAULT_ACCOUNT="prod"

# finding the proper sso-lib
export AWSLIB="devops"
# fall back to aws-sso-util when devops isn't available.
[[ ! -e "${DEFAULT_AWSLIB}" ]] && { 
    export AWSLIB="aws" 
    export DEFAULT_AWSLIB="${HOME}/.local/bin/${AWSLIB}-sso-util" 
} 


# -----------------------------------------------------------------
# ARG PARSING
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:arg_parsing"

account="${1:-"prod"}"


# -----------------------------------------------------------------
# SHELL LOADER 
# -----------------------------------------------------------------

# For loading associative arrays from files or variables.


to_debug stgs  echo LOADER_ACTIVE: "${LOADER_ACTIVE}"

. ${BT}/lib/utils.bash
bt_loader



# -----------------------------------------------------------------
# CACHE SETTINGS
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:cache"
set_team


# -----------------------------------------------------------------
# PATH SETTINGS
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:path"

[[ ! -f "${BT}"/cache/path_info ]] && {
  to_debug stgs && sleep 1 && echo stgs:path_info
  "${BT}"/utils/path -s 2>/dev/null | tee ${BT}/cache/path_info 
}

to_debug stgs && sleep 1 && echo stgs:source_path
source <(echo "$("${BT}"/utils/path -s 2>/dev/null)" )

# -----------------------------------------------------------------
# ESSENTIAL ALIASES
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:aliases"

#poetry="$(which poetry)"

# ssm tool.
#alias ssm_cmpl=". ${BT}/src/ssm.cmpl"
#alias ssm="ssm_cmpl; poetry run poe ssm ${@}"

# rds tool.
#alias rds_cmpl=". ${BT}/src/rds.cmpl"
#alias rds="rds_cmpl; poetry run poe rds ${@}"

# other.
#alias rds_term="poetry run poe rds_cmpl && poetry run poe rds ${@}"
#alias dg="poetry run poe rds_cmpl && poetry run poe dg ${@}"



# -----------------------------------------------------------------
# ENV SETTINGS
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:env"

# scripted shell activation (experimental).
#[[ -e "${HOME}/.bt/.iterm2_shell_integration.bash" ]] && { 
#  source "${HOME}/.iterm2_shell_integration.bash"
#}

# defaults should be generated by the loader.
to_debug stgs && echo stgs:env BT_TEAM   : ${BT_TEAM} 
to_debug stgs && echo stgs:env BT_ACCOUNT: ${BT_ACCOUNT} 
to_debug stgs && echo stgs:env BT_ROLE:    ${BT_ROLE}



# -----------------------------------------------------------------
# Bootstrap functions.
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:bootstrap_funcs"




# -----------------------------------------------------------------
# AWS LOGIN
# -----------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:autologin"

# Uncomment this if you want logins to happen 
# through settings.  Team account defaults to prod, for now.
# autologin "${account}" 





# ------------------------------------------------------------------
# load bintools functions, customizations, completions.
# ------------------------------------------------------------------

to_debug flow && sleep 0.5 && echo "stgs:sources"

role=qventus 
[[ -n "${BT_ROLE}" ]] && { role="${BT_ROLE}" ;}
autologin $role 

q() {  
 : 
  # ----------------------------------------------------------------
  # GENERATORS 
  # ----------------------------------------------------------------
  # Scripts that generate bintools automated configs.
  # See: ${BT}/utils/gen
  
  # ----------------------------------------------------------------
  # SOURCING
  # ----------------------------------------------------------------
  # Bintools does a lot of sourcing to create a productive environment. 
  #
  # Globbing
  # --------
  # Advanced globbing is an easy way to sort through files. 
  # 
  #shopt -q extglob;     extglob_set=$?
  #((extglob_set))     && shopt -s extglob

  # Array of dirs where source files live.
  # As a rule, these are sourced ONLY from here, and ONLY once.
#  declare -a dirs
#  dirs=(           \
#    src            \
#  )                
#
#  for d in $(printf "%s\n" "${dirs[@]}"); do
#    # sources dirs only. 
#    [[ "${d}" = src* ]] || continue  
#    DIR="${BT}/${d}" && q_pushd 2>/dev/null "${DIR}"
#    echo -ne "\n\n${BLUE}Sourcing in ${DIR}...${NC}\n\n"
#    # shellcheck disable=SC2125
#    glob=[!_]?*
#    files=( "$( printf "%s\n" "${glob}")" )
# 
#    # longest file. 
#    lg=0
#    for f in $(printf '%s' "${files[@]}"); do 
#      this=${#f}
#      [[ "$lg" -le "$this" ]] && lg=$this 
#    done
# 
#    for f in $(printf '%s' "${files[@]}"); do
#      [[ ${f} = *.@(new|cmpl|src|gen|arr$) ]] || continue
#      src_str="\t./${f}"
#      # shellcheck disable=SC1090,SC1094 
#      source ./"${f}" >/dev/null 2>&1    && \
#      status="success!" COLOR="${GREEN}" || \
#      status="failed."  COLOR="${RED}"  
#      printf "%b%*.b%b${COLOR}%s${NC}%b\n"  \
#          "$src_str" $(( lg - "${#f}" + 10 )) "."30 "" "${status}"
#    done
#    # shellcheck disable=SC2119
#    q_popd && "echo thanks!"
#  done
#
#  echo _____ 

#  ((extglob_set))     && shopt -u extglob
#  echo -ne "\n\n\n"
  
  # For fun, show a pretty tree-based display.  
#  tree -a -C "${BT}"/src --noreport --dirsfirst -F
}

# shellcheck disable=SC2015
#[[ "${BT_SETTINGS}" = *quiet* ]] && q > /dev/null 2>&1 || q

